import { type AssignmentKind, type DestructuringKind, Flags, type Location } from '../common';
import { Errors } from '../errors';
import type * as ESTree from '../estree';
import { type NormalizedOptions, type Options } from '../options';
import { Token } from '../token';
import { PrivateScope } from './private-scope';
import { Scope, type ScopeKind } from './scope';
export declare class Parser {
    readonly source: string;
    private lastOnToken;
    options: NormalizedOptions;
    token: Token;
    flags: Flags;
    index: number;
    line: number;
    column: number;
    startIndex: number;
    end: number;
    tokenIndex: number;
    startColumn: number;
    tokenColumn: number;
    tokenLine: number;
    startLine: number;
    tokenValue: any;
    tokenRaw: string;
    tokenRegExp: void | {
        pattern: string;
        flags: string;
    };
    currentChar: number;
    exportedNames: Set<string>;
    exportedBindings: Set<string>;
    assignable: AssignmentKind | DestructuringKind;
    destructible: AssignmentKind | DestructuringKind;
    leadingDecorators: {
        start?: Location;
        decorators: ESTree.Decorator[];
    };
    comments: Array<ESTree.Comment>;
    leadingComments: Array<Array<ESTree.Comment>>;
    constructor(source: string, rawOptions?: Options);
    getToken(): Token;
    setToken(value: Token, replaceLast?: boolean): Token;
    get tokenStart(): Location;
    get currentLocation(): Location;
    finishNode<T extends ESTree.Node>(node: T, start: Location, end: Location | void): T;
    addBindingToExports(name: string): void;
    declareUnboundVariable(name: string): void;
    report(type: Errors, ...params: string[]): never;
    createScopeIfLexical(type?: ScopeKind, parent?: Scope): Scope | undefined;
    createScope(type?: ScopeKind, parent?: Scope): Scope;
    createPrivateScopeIfLexical(parent?: PrivateScope): PrivateScope | undefined;
    cloneIdentifier(original: ESTree.Identifier): ESTree.Identifier;
    cloneStringLiteral(original: ESTree.StringLiteral): ESTree.StringLiteral;
    private cloneLocationInformation;
}
